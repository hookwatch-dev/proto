// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v3.21.12
// source: cron.proto

package cronv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	CronService_GetPendingExecutions_FullMethodName = "/hookwatch.cron.v1.CronService/GetPendingExecutions"
	CronService_ClaimExecution_FullMethodName       = "/hookwatch.cron.v1.CronService/ClaimExecution"
	CronService_UpdateExecution_FullMethodName      = "/hookwatch.cron.v1.CronService/UpdateExecution"
	CronService_GetJobCommand_FullMethodName        = "/hookwatch.cron.v1.CronService/GetJobCommand"
	CronService_ListCronJobs_FullMethodName         = "/hookwatch.cron.v1.CronService/ListCronJobs"
	CronService_GetCronJob_FullMethodName           = "/hookwatch.cron.v1.CronService/GetCronJob"
	CronService_CreateCronJob_FullMethodName        = "/hookwatch.cron.v1.CronService/CreateCronJob"
	CronService_UpdateCronJob_FullMethodName        = "/hookwatch.cron.v1.CronService/UpdateCronJob"
	CronService_DeleteCronJob_FullMethodName        = "/hookwatch.cron.v1.CronService/DeleteCronJob"
	CronService_EnableCronJob_FullMethodName        = "/hookwatch.cron.v1.CronService/EnableCronJob"
	CronService_DisableCronJob_FullMethodName       = "/hookwatch.cron.v1.CronService/DisableCronJob"
	CronService_RunCronJob_FullMethodName           = "/hookwatch.cron.v1.CronService/RunCronJob"
	CronService_GetNextCronRuns_FullMethodName      = "/hookwatch.cron.v1.CronService/GetNextCronRuns"
	CronService_ListCronExecutions_FullMethodName   = "/hookwatch.cron.v1.CronService/ListCronExecutions"
	CronService_GetCronExecution_FullMethodName     = "/hookwatch.cron.v1.CronService/GetCronExecution"
	CronService_RetryCronExecution_FullMethodName   = "/hookwatch.cron.v1.CronService/RetryCronExecution"
	CronService_ReportCronExecution_FullMethodName  = "/hookwatch.cron.v1.CronService/ReportCronExecution"
)

// CronServiceClient is the client API for CronService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// CronService handles cron job management and execution coordination between CLI and core.
type CronServiceClient interface {
	// GetPendingExecutions returns executions waiting to be picked up by a CLI agent.
	GetPendingExecutions(ctx context.Context, in *GetPendingExecutionsRequest, opts ...grpc.CallOption) (*GetPendingExecutionsResponse, error)
	// ClaimExecution marks an execution as running (claimed by a CLI agent).
	ClaimExecution(ctx context.Context, in *ClaimExecutionRequest, opts ...grpc.CallOption) (*ClaimExecutionResponse, error)
	// UpdateExecution updates an execution with the result after local execution.
	UpdateExecution(ctx context.Context, in *UpdateExecutionRequest, opts ...grpc.CallOption) (*UpdateExecutionResponse, error)
	// GetJobCommand returns the command details for a job so the CLI can execute it.
	GetJobCommand(ctx context.Context, in *GetJobCommandRequest, opts ...grpc.CallOption) (*GetJobCommandResponse, error)
	// ListCronJobs returns all cron jobs for the authenticated user.
	ListCronJobs(ctx context.Context, in *ListCronJobsRequest, opts ...grpc.CallOption) (*ListCronJobsResponse, error)
	// GetCronJob returns a single cron job by ID.
	GetCronJob(ctx context.Context, in *GetCronJobRequest, opts ...grpc.CallOption) (*GetCronJobResponse, error)
	// CreateCronJob creates a new cron job.
	CreateCronJob(ctx context.Context, in *CreateCronJobRequest, opts ...grpc.CallOption) (*CreateCronJobResponse, error)
	// UpdateCronJob updates an existing cron job.
	UpdateCronJob(ctx context.Context, in *UpdateCronJobRequest, opts ...grpc.CallOption) (*UpdateCronJobResponse, error)
	// DeleteCronJob deletes a cron job.
	DeleteCronJob(ctx context.Context, in *DeleteCronJobRequest, opts ...grpc.CallOption) (*DeleteCronJobResponse, error)
	// EnableCronJob enables a cron job.
	EnableCronJob(ctx context.Context, in *EnableCronJobRequest, opts ...grpc.CallOption) (*EnableCronJobResponse, error)
	// DisableCronJob disables a cron job.
	DisableCronJob(ctx context.Context, in *DisableCronJobRequest, opts ...grpc.CallOption) (*DisableCronJobResponse, error)
	// RunCronJob triggers a manual execution of a cron job.
	RunCronJob(ctx context.Context, in *RunCronJobRequest, opts ...grpc.CallOption) (*RunCronJobResponse, error)
	// GetNextCronRuns returns the next scheduled runs for enabled jobs.
	GetNextCronRuns(ctx context.Context, in *GetNextCronRunsRequest, opts ...grpc.CallOption) (*GetNextCronRunsResponse, error)
	// ListCronExecutions returns executions with optional filters.
	ListCronExecutions(ctx context.Context, in *ListCronExecutionsRequest, opts ...grpc.CallOption) (*ListCronExecutionsResponse, error)
	// GetCronExecution returns a single execution by ID.
	GetCronExecution(ctx context.Context, in *GetCronExecutionRequest, opts ...grpc.CallOption) (*GetCronExecutionResponse, error)
	// RetryCronExecution creates a retry of a previous execution.
	RetryCronExecution(ctx context.Context, in *RetryCronExecutionRequest, opts ...grpc.CallOption) (*RetryCronExecutionResponse, error)
	// ReportCronExecution reports a local execution result to the cloud.
	ReportCronExecution(ctx context.Context, in *ReportCronExecutionRequest, opts ...grpc.CallOption) (*ReportCronExecutionResponse, error)
}

type cronServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCronServiceClient(cc grpc.ClientConnInterface) CronServiceClient {
	return &cronServiceClient{cc}
}

func (c *cronServiceClient) GetPendingExecutions(ctx context.Context, in *GetPendingExecutionsRequest, opts ...grpc.CallOption) (*GetPendingExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPendingExecutionsResponse)
	err := c.cc.Invoke(ctx, CronService_GetPendingExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) ClaimExecution(ctx context.Context, in *ClaimExecutionRequest, opts ...grpc.CallOption) (*ClaimExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClaimExecutionResponse)
	err := c.cc.Invoke(ctx, CronService_ClaimExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) UpdateExecution(ctx context.Context, in *UpdateExecutionRequest, opts ...grpc.CallOption) (*UpdateExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateExecutionResponse)
	err := c.cc.Invoke(ctx, CronService_UpdateExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) GetJobCommand(ctx context.Context, in *GetJobCommandRequest, opts ...grpc.CallOption) (*GetJobCommandResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetJobCommandResponse)
	err := c.cc.Invoke(ctx, CronService_GetJobCommand_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) ListCronJobs(ctx context.Context, in *ListCronJobsRequest, opts ...grpc.CallOption) (*ListCronJobsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCronJobsResponse)
	err := c.cc.Invoke(ctx, CronService_ListCronJobs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) GetCronJob(ctx context.Context, in *GetCronJobRequest, opts ...grpc.CallOption) (*GetCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCronJobResponse)
	err := c.cc.Invoke(ctx, CronService_GetCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) CreateCronJob(ctx context.Context, in *CreateCronJobRequest, opts ...grpc.CallOption) (*CreateCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCronJobResponse)
	err := c.cc.Invoke(ctx, CronService_CreateCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) UpdateCronJob(ctx context.Context, in *UpdateCronJobRequest, opts ...grpc.CallOption) (*UpdateCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateCronJobResponse)
	err := c.cc.Invoke(ctx, CronService_UpdateCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) DeleteCronJob(ctx context.Context, in *DeleteCronJobRequest, opts ...grpc.CallOption) (*DeleteCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteCronJobResponse)
	err := c.cc.Invoke(ctx, CronService_DeleteCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) EnableCronJob(ctx context.Context, in *EnableCronJobRequest, opts ...grpc.CallOption) (*EnableCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EnableCronJobResponse)
	err := c.cc.Invoke(ctx, CronService_EnableCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) DisableCronJob(ctx context.Context, in *DisableCronJobRequest, opts ...grpc.CallOption) (*DisableCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DisableCronJobResponse)
	err := c.cc.Invoke(ctx, CronService_DisableCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) RunCronJob(ctx context.Context, in *RunCronJobRequest, opts ...grpc.CallOption) (*RunCronJobResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RunCronJobResponse)
	err := c.cc.Invoke(ctx, CronService_RunCronJob_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) GetNextCronRuns(ctx context.Context, in *GetNextCronRunsRequest, opts ...grpc.CallOption) (*GetNextCronRunsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNextCronRunsResponse)
	err := c.cc.Invoke(ctx, CronService_GetNextCronRuns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) ListCronExecutions(ctx context.Context, in *ListCronExecutionsRequest, opts ...grpc.CallOption) (*ListCronExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCronExecutionsResponse)
	err := c.cc.Invoke(ctx, CronService_ListCronExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) GetCronExecution(ctx context.Context, in *GetCronExecutionRequest, opts ...grpc.CallOption) (*GetCronExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCronExecutionResponse)
	err := c.cc.Invoke(ctx, CronService_GetCronExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) RetryCronExecution(ctx context.Context, in *RetryCronExecutionRequest, opts ...grpc.CallOption) (*RetryCronExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetryCronExecutionResponse)
	err := c.cc.Invoke(ctx, CronService_RetryCronExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) ReportCronExecution(ctx context.Context, in *ReportCronExecutionRequest, opts ...grpc.CallOption) (*ReportCronExecutionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReportCronExecutionResponse)
	err := c.cc.Invoke(ctx, CronService_ReportCronExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CronServiceServer is the server API for CronService service.
// All implementations must embed UnimplementedCronServiceServer
// for forward compatibility.
//
// CronService handles cron job management and execution coordination between CLI and core.
type CronServiceServer interface {
	// GetPendingExecutions returns executions waiting to be picked up by a CLI agent.
	GetPendingExecutions(context.Context, *GetPendingExecutionsRequest) (*GetPendingExecutionsResponse, error)
	// ClaimExecution marks an execution as running (claimed by a CLI agent).
	ClaimExecution(context.Context, *ClaimExecutionRequest) (*ClaimExecutionResponse, error)
	// UpdateExecution updates an execution with the result after local execution.
	UpdateExecution(context.Context, *UpdateExecutionRequest) (*UpdateExecutionResponse, error)
	// GetJobCommand returns the command details for a job so the CLI can execute it.
	GetJobCommand(context.Context, *GetJobCommandRequest) (*GetJobCommandResponse, error)
	// ListCronJobs returns all cron jobs for the authenticated user.
	ListCronJobs(context.Context, *ListCronJobsRequest) (*ListCronJobsResponse, error)
	// GetCronJob returns a single cron job by ID.
	GetCronJob(context.Context, *GetCronJobRequest) (*GetCronJobResponse, error)
	// CreateCronJob creates a new cron job.
	CreateCronJob(context.Context, *CreateCronJobRequest) (*CreateCronJobResponse, error)
	// UpdateCronJob updates an existing cron job.
	UpdateCronJob(context.Context, *UpdateCronJobRequest) (*UpdateCronJobResponse, error)
	// DeleteCronJob deletes a cron job.
	DeleteCronJob(context.Context, *DeleteCronJobRequest) (*DeleteCronJobResponse, error)
	// EnableCronJob enables a cron job.
	EnableCronJob(context.Context, *EnableCronJobRequest) (*EnableCronJobResponse, error)
	// DisableCronJob disables a cron job.
	DisableCronJob(context.Context, *DisableCronJobRequest) (*DisableCronJobResponse, error)
	// RunCronJob triggers a manual execution of a cron job.
	RunCronJob(context.Context, *RunCronJobRequest) (*RunCronJobResponse, error)
	// GetNextCronRuns returns the next scheduled runs for enabled jobs.
	GetNextCronRuns(context.Context, *GetNextCronRunsRequest) (*GetNextCronRunsResponse, error)
	// ListCronExecutions returns executions with optional filters.
	ListCronExecutions(context.Context, *ListCronExecutionsRequest) (*ListCronExecutionsResponse, error)
	// GetCronExecution returns a single execution by ID.
	GetCronExecution(context.Context, *GetCronExecutionRequest) (*GetCronExecutionResponse, error)
	// RetryCronExecution creates a retry of a previous execution.
	RetryCronExecution(context.Context, *RetryCronExecutionRequest) (*RetryCronExecutionResponse, error)
	// ReportCronExecution reports a local execution result to the cloud.
	ReportCronExecution(context.Context, *ReportCronExecutionRequest) (*ReportCronExecutionResponse, error)
	mustEmbedUnimplementedCronServiceServer()
}

// UnimplementedCronServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCronServiceServer struct{}

func (UnimplementedCronServiceServer) GetPendingExecutions(context.Context, *GetPendingExecutionsRequest) (*GetPendingExecutionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPendingExecutions not implemented")
}
func (UnimplementedCronServiceServer) ClaimExecution(context.Context, *ClaimExecutionRequest) (*ClaimExecutionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ClaimExecution not implemented")
}
func (UnimplementedCronServiceServer) UpdateExecution(context.Context, *UpdateExecutionRequest) (*UpdateExecutionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateExecution not implemented")
}
func (UnimplementedCronServiceServer) GetJobCommand(context.Context, *GetJobCommandRequest) (*GetJobCommandResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetJobCommand not implemented")
}
func (UnimplementedCronServiceServer) ListCronJobs(context.Context, *ListCronJobsRequest) (*ListCronJobsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCronJobs not implemented")
}
func (UnimplementedCronServiceServer) GetCronJob(context.Context, *GetCronJobRequest) (*GetCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCronJob not implemented")
}
func (UnimplementedCronServiceServer) CreateCronJob(context.Context, *CreateCronJobRequest) (*CreateCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateCronJob not implemented")
}
func (UnimplementedCronServiceServer) UpdateCronJob(context.Context, *UpdateCronJobRequest) (*UpdateCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateCronJob not implemented")
}
func (UnimplementedCronServiceServer) DeleteCronJob(context.Context, *DeleteCronJobRequest) (*DeleteCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteCronJob not implemented")
}
func (UnimplementedCronServiceServer) EnableCronJob(context.Context, *EnableCronJobRequest) (*EnableCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method EnableCronJob not implemented")
}
func (UnimplementedCronServiceServer) DisableCronJob(context.Context, *DisableCronJobRequest) (*DisableCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DisableCronJob not implemented")
}
func (UnimplementedCronServiceServer) RunCronJob(context.Context, *RunCronJobRequest) (*RunCronJobResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RunCronJob not implemented")
}
func (UnimplementedCronServiceServer) GetNextCronRuns(context.Context, *GetNextCronRunsRequest) (*GetNextCronRunsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNextCronRuns not implemented")
}
func (UnimplementedCronServiceServer) ListCronExecutions(context.Context, *ListCronExecutionsRequest) (*ListCronExecutionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListCronExecutions not implemented")
}
func (UnimplementedCronServiceServer) GetCronExecution(context.Context, *GetCronExecutionRequest) (*GetCronExecutionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCronExecution not implemented")
}
func (UnimplementedCronServiceServer) RetryCronExecution(context.Context, *RetryCronExecutionRequest) (*RetryCronExecutionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RetryCronExecution not implemented")
}
func (UnimplementedCronServiceServer) ReportCronExecution(context.Context, *ReportCronExecutionRequest) (*ReportCronExecutionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportCronExecution not implemented")
}
func (UnimplementedCronServiceServer) mustEmbedUnimplementedCronServiceServer() {}
func (UnimplementedCronServiceServer) testEmbeddedByValue()                     {}

// UnsafeCronServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CronServiceServer will
// result in compilation errors.
type UnsafeCronServiceServer interface {
	mustEmbedUnimplementedCronServiceServer()
}

func RegisterCronServiceServer(s grpc.ServiceRegistrar, srv CronServiceServer) {
	// If the following call panics, it indicates UnimplementedCronServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CronService_ServiceDesc, srv)
}

func _CronService_GetPendingExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPendingExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).GetPendingExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_GetPendingExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).GetPendingExecutions(ctx, req.(*GetPendingExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_ClaimExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClaimExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).ClaimExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_ClaimExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).ClaimExecution(ctx, req.(*ClaimExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_UpdateExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).UpdateExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_UpdateExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).UpdateExecution(ctx, req.(*UpdateExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_GetJobCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetJobCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).GetJobCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_GetJobCommand_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).GetJobCommand(ctx, req.(*GetJobCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_ListCronJobs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCronJobsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).ListCronJobs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_ListCronJobs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).ListCronJobs(ctx, req.(*ListCronJobsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_GetCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).GetCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_GetCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).GetCronJob(ctx, req.(*GetCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_CreateCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).CreateCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_CreateCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).CreateCronJob(ctx, req.(*CreateCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_UpdateCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).UpdateCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_UpdateCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).UpdateCronJob(ctx, req.(*UpdateCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_DeleteCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).DeleteCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_DeleteCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).DeleteCronJob(ctx, req.(*DeleteCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_EnableCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).EnableCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_EnableCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).EnableCronJob(ctx, req.(*EnableCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_DisableCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).DisableCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_DisableCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).DisableCronJob(ctx, req.(*DisableCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_RunCronJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunCronJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).RunCronJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_RunCronJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).RunCronJob(ctx, req.(*RunCronJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_GetNextCronRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextCronRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).GetNextCronRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_GetNextCronRuns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).GetNextCronRuns(ctx, req.(*GetNextCronRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_ListCronExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCronExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).ListCronExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_ListCronExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).ListCronExecutions(ctx, req.(*ListCronExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_GetCronExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCronExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).GetCronExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_GetCronExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).GetCronExecution(ctx, req.(*GetCronExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_RetryCronExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetryCronExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).RetryCronExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_RetryCronExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).RetryCronExecution(ctx, req.(*RetryCronExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CronService_ReportCronExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportCronExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CronServiceServer).ReportCronExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CronService_ReportCronExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CronServiceServer).ReportCronExecution(ctx, req.(*ReportCronExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CronService_ServiceDesc is the grpc.ServiceDesc for CronService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CronService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hookwatch.cron.v1.CronService",
	HandlerType: (*CronServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPendingExecutions",
			Handler:    _CronService_GetPendingExecutions_Handler,
		},
		{
			MethodName: "ClaimExecution",
			Handler:    _CronService_ClaimExecution_Handler,
		},
		{
			MethodName: "UpdateExecution",
			Handler:    _CronService_UpdateExecution_Handler,
		},
		{
			MethodName: "GetJobCommand",
			Handler:    _CronService_GetJobCommand_Handler,
		},
		{
			MethodName: "ListCronJobs",
			Handler:    _CronService_ListCronJobs_Handler,
		},
		{
			MethodName: "GetCronJob",
			Handler:    _CronService_GetCronJob_Handler,
		},
		{
			MethodName: "CreateCronJob",
			Handler:    _CronService_CreateCronJob_Handler,
		},
		{
			MethodName: "UpdateCronJob",
			Handler:    _CronService_UpdateCronJob_Handler,
		},
		{
			MethodName: "DeleteCronJob",
			Handler:    _CronService_DeleteCronJob_Handler,
		},
		{
			MethodName: "EnableCronJob",
			Handler:    _CronService_EnableCronJob_Handler,
		},
		{
			MethodName: "DisableCronJob",
			Handler:    _CronService_DisableCronJob_Handler,
		},
		{
			MethodName: "RunCronJob",
			Handler:    _CronService_RunCronJob_Handler,
		},
		{
			MethodName: "GetNextCronRuns",
			Handler:    _CronService_GetNextCronRuns_Handler,
		},
		{
			MethodName: "ListCronExecutions",
			Handler:    _CronService_ListCronExecutions_Handler,
		},
		{
			MethodName: "GetCronExecution",
			Handler:    _CronService_GetCronExecution_Handler,
		},
		{
			MethodName: "RetryCronExecution",
			Handler:    _CronService_RetryCronExecution_Handler,
		},
		{
			MethodName: "ReportCronExecution",
			Handler:    _CronService_ReportCronExecution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cron.proto",
}
